<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// THANOS CAR
/*
    Cel-shaded / Pixelated fire
*/
/// THANOS CAR
time = 0;
mouse_xprev = -1;
mouse_yprev = -1;
clearSurface = true; // variable to clear the surfaces on first frame

// Screen size related
WIN_WID = room_width;
WIN_HEI = room_height;
RES_WID = WIN_WID &gt;&gt; 2;
RES_HEI = WIN_HEI &gt;&gt; 2;

// Fire's cooling map texture. Different noise means different patterns of fire.
texCoolingMap = sprite_get_texture(texPerlin256, 0);

// The Fire buffer[tm]; We'll use this to calculate the fire and smoke.
surfFire = surface_create(RES_WID, RES_HEI);
surfFireTemp = surface_create(RES_WID, RES_HEI); // temporary buffer surface to hold the calculated result of fire
texFire = surface_get_texture(surfFire);

// Regular surface / source image; we're gonna draw this onto fire buffer, fully white. 
surfGame = surface_create(RES_WID, RES_HEI);

// Composite surface for bloom effect
surfComposite = surface_create(WIN_WID, WIN_HEI);

// Shader uniforms
uCoolingMap = shader_get_sampler_index(shd_fire, "u_coolingmap");
uSource = shader_get_sampler_index(shd_fire, "u_source");
uTextureSize = shader_get_uniform(shd_fire, "u_texturesize");
uTime = shader_get_uniform(shd_fire, "u_time");
uScrollSpeed = shader_get_uniform(shd_fire, "u_scrollspeed");
uWindStrength = shader_get_uniform(shd_fire, "u_windstrength");
uWindSpeed = shader_get_uniform(shd_fire, "u_windspeed");

uBurnIntensity = shader_get_uniform(shd_burn, "u_intensity");
uBurnMap = shader_get_sampler_index(shd_burn, "u_texture");
uBurnTime = shader_get_sampler_index(shd_burn, "u_time");

uFireCol1 = shader_get_uniform(shd_fire_effect_cartoon, "u_colourmid");
uFireCol2 = shader_get_uniform(shd_fire_effect_cartoon, "u_colourcore");
uFireCol3 = shader_get_uniform(shd_fire_effect_cartoon, "u_coloursmoke");

uMlgTime = shader_get_uniform(shd_mlg_boomer, "u_time");
uBloom = shader_get_uniform(shd_startrek_bloom, "intensity");

// Disable interpolation for crispy pixel effect
texture_set_interpolation(false);
display_reset(0, false);
texture_set_interpolation(false);

draw_set_font(fntHangul);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Surface heartbeat &amp; time update
// Check if surfaces are long goner &amp; rebuild it
if (!surface_exists(surfFire))
{
    surfFire = surface_create(RES_WID, RES_HEI);
    texFire = surface_get_texture(surfFire);
}

if (!surface_exists(surfGame))
    surfGame = surface_create(RES_WID, RES_HEI);

if (!surface_exists(surfFireTemp))
    surfFireTemp = surface_create(RES_WID, RES_HEI);
    
if (!surface_exists(surfComposite))
    surfComposite = surface_create(WIN_WID, WIN_HEI);

// Time
time += 2;

</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Go to next demo
if (keyboard_check_pressed(vk_enter))
    room_goto(rm_main);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="5">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Free memories
if (surface_exists(surfFire))
{
    surface_set_target(surfFire);
    draw_clear_alpha(0, 0);
    surface_reset_target();
    surface_set_target(surfFireTemp);
    draw_clear_alpha(0, 0);
    surface_reset_target();
    surface_free(surfFire);
    surface_free(surfFireTemp);
    texFire = -1;
    surfFireTemp = -1;
}
    
if (surface_exists(surfGame))
{
    surface_set_target(surfGame);
    draw_clear_alpha(0, 0);
    surface_reset_target();
    surface_free(surfGame);
}

if (surface_exists(surfComposite))
    surface_free(surfComposite);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Draw source image
surface_set_target(surfGame);
draw_clear_alpha(0, 0);

// Bottom fire
var _hei = 4;
var _fireblue = $ffe5db;
draw_rectangle_colour(0, RES_HEI - _hei, RES_WID, RES_HEI, _fireblue, _fireblue, _fireblue, _fireblue, false);

// center pos
var _cx = RES_WID &gt;&gt; 1;
var _cy = RES_HEI &gt;&gt; 1;

// Drunk scottish explosion man's precious face (disintegration effect)
shader_set(shd_burn);
// uniforms
shader_set_uniform_f(uBurnTime, time);
shader_set_uniform_f(uBurnIntensity, sin(time * 0.02) * 0.5 + 0.5);
texture_set_stage(uBurnMap, texCoolingMap);

draw_sprite_ext(sprMEAT, 2, _cx, _cy + 40, 0.3, 0.3, time * 2, c_white, 1.0);
shader_reset();

// Random gibberish
draw_set_halign(1);draw_set_valign(1);
draw_set_font(fntBonehurtingjuice);
var _rainbow = merge_colour($00DDFF, $FFDD00, (time &gt;&gt; 3) &amp; 1);//make_colour_hsv(time * 2, 255, 255);
var _gibberish = "SUPER#MEAT BALLS";
draw_text_transformed_colour(_cx, _cy - 30 + 1, _gibberish, 0.5, 0.5, 0, c_black, c_black, c_black, c_black, 1.0);
draw_text_transformed_colour(_cx, _cy - 30 - 1, _gibberish, 0.5, 0.5, 0, c_black, c_black, c_black, c_black, 1.0);
draw_text_transformed_colour(_cx - 1, _cy - 30, _gibberish, 0.5, 0.5, 0, c_black, c_black, c_black, c_black, 1.0);
draw_text_transformed_colour(_cx + 1, _cy - 30, _gibberish, 0.5, 0.5, 0, c_black, c_black, c_black, c_black, 1.0);
draw_text_transformed_colour(_cx, _cy - 30, _gibberish, 0.5, 0.5, 0, _rainbow, _rainbow, _rainbow, _rainbow, 1.0);
draw_set_font(fntHangul);
draw_set_halign(0);draw_set_valign(0);
surface_reset_target();

</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Fire buffer update
surface_set_target(surfFire);

// Clear the contents of surface to prevent digital gunks on first frame
if (clearSurface)
{
    clearSurface = false;
    draw_clear(0);
}

// Draw source image / regular surface fully white
d3d_set_fog(true, c_white, 0, 0);
draw_surface(surfGame, 0, 0);
d3d_set_fog(false, 0, 0, 0);

// Draw fire with mouse
var _ratiox = mouse_x / (WIN_WID / RES_WID);
var _ratioy = mouse_y / (WIN_HEI / RES_HEI);
var _subs = 16;
    
if (mouse_check_button(mb_left))
{
    for (var i=0; i&lt;=_subs; i++)
    {
        var _incr = i / _subs;
        draw_circle_colour(lerp(_ratiox, mouse_xprev, _incr), lerp(_ratioy, mouse_yprev, _incr), 8, c_white, c_white, false);
    }
}

mouse_xprev = _ratiox;
mouse_yprev = _ratioy;
surface_reset_target();

</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Fire effect

// 1] Calculate fire using surfFire &amp; save it to temporary surface
surface_set_target(surfFireTemp);
shader_set(shd_fire);
// uniforms
texFire = surface_get_texture(surfFire);
shader_set_uniform_f(uTextureSize, RES_WID, RES_HEI); // Texture size
shader_set_uniform_f(uTime, time); // Time
shader_set_uniform_f(uScrollSpeed, 2); // Fire Scroll speed
shader_set_uniform_f(uWindStrength, 4); // Wind strength
shader_set_uniform_f(uWindSpeed, 4); // Wind speed
texture_set_stage(uCoolingMap, texCoolingMap); // Cooling map
texture_set_stage(uSource, texFire); // Source Texture of surfFire

// (see oREAL_FIRE object to see why are we drawing a surface in the line below :)
draw_surface(surfFire, 0, 0);
shader_reset();
surface_reset_target();

// 1-1] Transfer the calculated fire effect to original surfFire surface
surface_set_target(surfFire);
draw_surface(surfFireTemp, 0, 0);
surface_reset_target();

// 2-1] Background
surface_set_target(surfComposite);
draw_clear(0);
shader_set(shd_mlg_boomer);
shader_set_uniform_f(uMlgTime, time); // time
draw_sprite(bgKot, 1, WIN_WID / 2, WIN_HEI / 2);
shader_reset();


// 2-2] Fire effect
shader_set(shd_fire_effect_cartoon);
// !!RAINBOW*FIRE!!
var _rainbow1 = make_colour_hsv((time * 0.1) % 255, 230, 220);
var _rainbow2 = make_colour_hsv((time * 0.1 + 10) % 255, 100, 255);
shader_set_uniform_f(uFireCol1, colour_get_red(_rainbow1) / 255, colour_get_green(_rainbow1) / 255, colour_get_blue(_rainbow1) / 255, 1);
shader_set_uniform_f(uFireCol2, colour_get_red(_rainbow2) / 255, colour_get_green(_rainbow2) / 255, colour_get_blue(_rainbow2) / 255, 1);
shader_set_uniform_f(uFireCol3, 0.28, 0.22, 0.2, 1);

draw_surface_stretched(surfFire, 0, 0, WIN_WID, WIN_HEI);
shader_reset();

// Regular surface / source image
draw_surface_stretched(surfGame, 0, 0, WIN_WID, WIN_HEI);
surface_reset_target();

// Bloom
shader_set(shd_startrek_bloom);
shader_set_uniform_f(uBloom, sin(time * 0.04 + cos(time * 0.25 + 123.0) * 0.5 + 0.42) * 0.5 + 0.5);
draw_surface(surfComposite, 0, 0);
shader_reset();

// info
draw_text(10, 10, "Press &lt;Enter&gt; key for previous demo#Drag with mouse to draw fire");
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
